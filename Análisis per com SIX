# %% [markdown]
# # Actualización del final de comisiones

# %%
import pandas as pd
import time
import pygame
import os
import numpy as np
import datetime
from datetime import datetime

start_time = time.time()
# Convertir a hora legible
hora_legible = datetime.fromtimestamp(start_time).strftime("%H:%M:%S")
print("Hora legible:", hora_legible)

# Cargar el DataFrame
año_a_evaluar = 2025

#base 2025                 
base_comisiones = pd.read_parquet(r"C:\Users\dominh05\Documents\SIX\Codigos_six\Comisiones\Bases Fregonas\Final_de_comisiones_historico.parquet")

base_comisiones['Fecha_de_comisión'] = pd.to_datetime({
    'year': base_comisiones['Año_Comision'],
    'month': base_comisiones['Mes'],
    'day': 1
})

ruta_tabla_htl = r'C:\Users\dominh05\Documents\SIX\Tabulador HTL y porcentaje de comision.xlsx'

#porcentaje de contrato y de hsk
porcentaje_de_contrato = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\HSK\Tabulador Ene - Jun_2025 - Jul.xlsx")
porcentaje_de_hsk = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\Tabulador HSK comision\2025\TABULADOR HSK - COMISIÓN JULIO 2025.xlsx", sheet_name='TGT HSK')

sa039 = pd.read_excel(r'C:\Users\dominh05\Documents\SIX\Data Financiera SA039 Acumulado.xlsx', sheet_name='SA039')

diccionario_datos_finanzas = dict(zip(sa039['Llave'], sa039['Monto']))
#diccionario de comisiones
diccionario_porcentaje_contrato = dict(zip(
    porcentaje_de_contrato['No.deNegocio'].astype(str),
    porcentaje_de_contrato['Tabulador 2025']
))
diccionario_porcentaje_HSK = dict(zip(
    porcentaje_de_hsk['CeCo'].astype(str),
    porcentaje_de_hsk['CV HSK']
))


estatus_dict = {
    'ACTIVOS': 'ACTIVOS',
    'BAJAS': 'BAJAS',
    'TRANSFERENCIA': 'TRANSFERENCIA',
    'ALTA': 'ALTA',
    'REACTIVACION': 'REACTIVACION',
    'REACTIVACIÓn': 'REACTIVACION',
    'Activos': 'ACTIVOS',
    'Bajas': 'BAJAS',
    'Transfer Feb25': 'TRANSFERENCIA',
    'Alta Feb 25': 'ALTA',
    'Transfer': 'TRANSFERENCIA',
    'Alta': 'ALTA',
    'VIRTUAL 4': 'VIRTUAL 4',
    'Transferencia': 'TRANSFERENCIA'
}
base_comisiones['STATUS'] = base_comisiones['STATUS'].map(estatus_dict)

base_comisiones['Cumple_Condiciones_Tienda_Activa'] = (
    ((base_comisiones['STATUS'] == 'ACTIVOS') | (base_comisiones['STATUS'] == 'ALTA')) & 
    (base_comisiones['MODALIDAD'] != 'PENSION') & 
    (base_comisiones['SIX'] != 'INDIRECTO') & 
    (base_comisiones['OCUPACIÓN'] == 'TOTAL') & 
    (base_comisiones['DIAS LABORADOS'] >= 26)
)
# base_comisiones = base_comisiones[
#     ((base_comisiones['STATUS'] == 'ACTIVOS') | (base_comisiones['STATUS'] == 'ALTA')) & 
#     (base_comisiones['MODALIDAD'] != 'PENSION') & 
#     (base_comisiones['SIX'] != 'INDIRECTO') & 
#     (base_comisiones['OCUPACIÓN'] == 'TOTAL') & 
#     (base_comisiones['DIAS LABORADOS'] >= 26)
# ].copy()
 
# Paso 1: Crear la columna 'Conteo acumulado mes'
base_comisiones['Conteo acumulado mes'] = base_comisiones.groupby(['No.SAPDENEGOCIO','NoDEPROVEEDOR']).cumcount() + 1
# Paso 2: Crear la columna 'MOPS' con el valor máximo de 'Conteo acumulado mes' para cada 'No.SAPDENEGOCIO'
base_comisiones['Meses_YTD'] = base_comisiones.groupby(['No.SAPDENEGOCIO','NoDEPROVEEDOR'])['Conteo acumulado mes'].transform('max')

tabla_hectolitraje = pd.read_excel(ruta_tabla_htl)

base_comisiones['Total Income sin subsidio'] = base_comisiones['Total Income']-base_comisiones['GARANTIAS (G)'] 

merged_df = base_comisiones

merged_df['HTL'] = merged_df['HTL'].fillna(0)

# Definir los límites de los rangos para HTL
bins = [0, 1.00000001, 1.50000001, 3.00000001, 5.00000001, 6.00000001, 8.00000001, 10.00000001, 
        11.00000001, 15.00000001, 20.00000001, 25.00000001, 30.00000001, 40.00000001, 
        60.00000001, 80.00000001, 100.00000001, float('inf')]

# Etiquetas para cada rango
labels = ['0 a 1', '>1 a 1.5', '>1.5 a 3', '>3 a 5', '>5 a 6', '>6 a 8', '>8 a 10', 
          '>10 a 11', '>11 a 15', '>15 a 20', '>20 a 25', '>25 a 30', '>30 a 40', 
          '>40 a 60', '>60 a 80', '>80 a 100', '>100']


# Crear la nueva columna 'Grupo HTL' con los rangos correspondientes
merged_df['Grupo_HTL_Mes'] = pd.cut(merged_df['HTL'], bins=bins, labels=labels, right=False)



# Crear la columna condicional
merged_df['Flag_Total_Income < 15000'] = merged_df['Total Income sin subsidio'].apply(lambda x: 1 if x < 15000 else 0)

#columnas para el desgloce del income
Columnas_OC_Directas = [
    "COMPLEMENTO DE COMISION FIJA/VARIABLE",
    "CIGARROS",
    "TAE",
    "PAGO RTD'S",
    "STRONGBOW",
    "SPIRITS",
    "ENERGIZANTES (BOOST)",
    "SUEROS ORALES",
    "SIM CARDS",
    "ENCENDEDORES",
    "CANIJILLA",
    "ARTICULOS SIX",
    "FARMACIA G",
    "FARMACIA M",
    "AGUA",
    "ENERGY DRINKS",
    "SERVICIOS ELECTRONICOS",
    "URBANI y VA y VEN"
]
merged_df['OC_Directas_Mes'] = merged_df[Columnas_OC_Directas].sum(axis=1)

Columnas_GEC = [
    "INCENTIVO CATEGORIAS DIRECTAS",
    "INCENTIVO CATEGORIAS INDIRECTAS"
]

merged_df['GEC_Mes'] = merged_df[Columnas_GEC].sum(axis=1)

Columnas_Redenciones = [
    "REDENCIONES LÁCTEOS",
    "REDENCIONES REFRESCOS",
    "REDENCIONES SNACK",
    "REDENCIONES HELADOS",    
    "REDENCIONES CIGARROS", 
]

merged_df['Redenciones_Mes'] = merged_df[Columnas_Redenciones].sum(axis=1)

columnas_ayudas_y_bonos = [
    "BONO DE BIENVENIDA",
    "BONO CERVEZA",
    "BONO EJECUCIÓN",
    "INSTRUCTOR INDIRECTO",
    "APOYO TEMPORAL COMODIN",
    "INSTRUCTOR",
    "CIERRE TEMPORAL",
    "GENTE COMO TU",
    "INCENTIVO USO POS",
    "INCENTIVO GLUP",
    "APOYOS (VARIOS)",
    "CONCEPTO APOYO (VARIOS)",
    "ANTICIPOS"
]

# Asegurar que las columnas sean numéricas, reemplazando valores no numéricos con 0
merged_df[columnas_ayudas_y_bonos] = merged_df[columnas_ayudas_y_bonos].apply(pd.to_numeric, errors='coerce').fillna(0)

# Realizar la suma de las columnas
merged_df['Ayudas_y_bonos_Mes'] = merged_df[columnas_ayudas_y_bonos].sum(axis=1)

#asigna stronghold o Challenger
merged_df['Territorio_Tipo'] = merged_df['REGION'].apply(lambda x: 'Stronghold' if x in ['NORESTE', 'NOROESTE', 'SURESTE'] else 'Challenger')

merged_df['Com_Cerveza_De_Contrato'] = merged_df['No.SAPDENEGOCIO'].map(diccionario_porcentaje_contrato)

merged_df['Porcentaje_de_hsk'] = merged_df['No.SAPDENEGOCIO'].map(diccionario_porcentaje_HSK)
merged_df['Com_Cerveza_de_hsk'] = merged_df['Porcentaje_de_hsk'] * merged_df['VENTA CERVEZA'] 
merged_df['Beneficio_HSK'] = merged_df['Com_Cerveza_de_hsk'] - merged_df['COMISIÓN CERVEZA']
merged_df['Cumplimiento_Comision_Contrato'] = merged_df['% COMISIÓN CERVEZA'] >= merged_df['Com_Cerveza_De_Contrato']


merged_df['Codigo_registro'] = merged_df['No.SAPDENEGOCIO'].astype(str) + \
                      merged_df['NoDEPROVEEDOR'].astype(str) + \
                      merged_df['Mes'].astype(str) + \
                      merged_df['Año_Comision'].astype(str)

merged_df['Codigo_registro_Tienda'] = merged_df['No.SAPDENEGOCIO'].astype(str) + \
                      merged_df['Mes'].astype(str) + \
                      merged_df['Año_Comision'].astype(str)

merged_df['Codigo_region_periodo'] = merged_df['REGION CORTA'].astype(str) + \
                      merged_df['Mes'].astype(str) + \
                      merged_df['Año_Comision'].astype(str)

#datos financieros

# Crear las llaves con OP, REVENUE y Sell_out
merged_df["Llave_OP"] = merged_df["REGION CORTA"].astype(str) + merged_df["Mes"].astype(str) + merged_df["Año_Comision"].astype(str) + "OP"
merged_df["Llave_Revenue"] = merged_df["REGION CORTA"].astype(str) + merged_df["Mes"].astype(str) + merged_df["Año_Comision"].astype(str) + "Revenue"
merged_df["Llave_Sell_out"] = merged_df["REGION CORTA"].astype(str) + merged_df["Mes"].astype(str) + merged_df["Año_Comision"].astype(str) + "Sell_out"

# Hacer el merge con sa039 para cada tipo de dato
merged_df['OP_Region_Mes'] = merged_df['Llave_OP'].map(diccionario_datos_finanzas)
merged_df['Revenue_Region_Mes'] = merged_df['Llave_Revenue'].map(diccionario_datos_finanzas)
merged_df['Sell_out_Region_Mes'] = merged_df['Llave_Sell_out'].map(diccionario_datos_finanzas)

# Eliminar las columnas auxiliares de llave
merged_df.drop(columns=["Llave_OP", "Llave_Revenue", "Llave_Sell_out"], inplace=True)

#creo que este pez no va a jalar, mejor tomar este tipo de datos del pnl
#op sobre htl
#merged_df['OP_por_HTL'] = merged_df['OP_Region_Mes'] /merged_df['Sell_out_Region_Mes'] * merged_df['HTL']
#merged_df['GI/OP Margin'] = merged_df['OP_Region_Mes'] /merged_df['Revenue_Region_Mes']

#aca si tira error es porque le cambie Mes a Mes
def asignar_quarter(mes):
    if mes in [1, 2, 3]:
        return 'Q1'
    elif mes in [4, 5, 6]:
        return 'Q2'
    elif mes in [7, 8, 9]:
        return 'Q3'
    elif mes in [10, 11, 12]:
        return 'Q4'
    else:
        return 'Mes inválido'
merged_df['Quarter'] = merged_df['Mes'].apply(asignar_quarter)
merged_df['Quarter_Year'] = merged_df['Quarter'] + merged_df['Año_Comision'].astype(str)

def asignar_semester(mes):
    if mes in [1, 2, 3, 4, 5, 6]:
        return 'S1'
    elif mes in [7, 8, 9,10, 11, 12]:
        return 'S2'
    else:
        return 'Mes inválido'
    

merged_df['Semester'] = merged_df['Mes'].apply(asignar_semester)
merged_df['Semester_Year'] = merged_df['Semester'] + merged_df['Año_Comision'].astype(str)


orden_columnas = [
    "REGION", "ZONA", "PLAZA", "No.SAPDENEGOCIO", "NOMBRE DEL NEGOCIO", "NoDEPROVEEDOR", 
    "NOMBRE DEL COMERCIANTE", "STATUS", "MODALIDAD", "TABULADOR", "SIX", "OCUPACIÓN", 
    "FECHA", "DIA", "MES", "AÑO", "DIAS LABORADOS", "VENTA CERVEZA", "% COMISIÓN CERVEZA", 
    "MONTO GARANTIZADO", "COMISIÓN CERVEZA", "COMPLEMENTO DE COMISION FIJA/VARIABLE", 
    "CIGARROS", "TAE", "PAGO RTD'S", "STRONGBOW", "SPIRITS", "ENERGIZANTES (BOOST)", 
    "SUEROS ORALES", "SIM CARDS", "ENCENDEDORES", "CANIJILLA", "ARTICULOS SIX", 
    "FARMACIA G", "FARMACIA M", "AGUA", "ENERGY DRINKS", "SERVICIOS ELECTRONICOS", "URBANI y VA y VEN",
    "INCENTIVO CATEGORIAS DIRECTAS", "INCENTIVO CATEGORIAS INDIRECTAS", 
    "REDENCIONES LÁCTEOS", "REDENCIONES REFRESCOS", "REDENCIONES SNACK", 
    "REDENCIONES HELADOS", "REDENCIONES CIGARROS", "BONO DE BIENVENIDA", "BONO CERVEZA", 
    "BONO EJECUCIÓN", "INSTRUCTOR INDIRECTO", "APOYO TEMPORAL COMODIN", "INSTRUCTOR", 
    "GARANTIAS (G)", "CIERRE TEMPORAL", "GENTE COMO TU", "INCENTIVO USO POS", 
    "INCENTIVO GLUP", "APOYOS (VARIOS)", "CONCEPTO APOYO (VARIOS)", "ANTICIPOS", 
    "PERCEPCION", "IVA", "INGRESO BRUTO", "IVA RET", "IMPUESTOS FEDERALES", 
    "HONORARIOS CONTADOR", "IMSS", "TIMBRADO", "RESICO", "AJUSTE DE COMISIÓN", 
    "GARANTÍA CONTABLE", "MULTAS", "DESCUENTO ENE ELEC", "PENALIZACIONES", "HIELO", 
    "PRODUCTOS COMPLEMENTARIOS", "PENSIÓN ALIMENTICIA", "GARANTÍA", "ANTICIPO", 
    "GASTOS FIJOS", "KIT DE SEGURIDAD", "USO POS", "MULTA NO VENTA A MENORES", 
    "HIPOTECARIO", "AJUSTE DE COMISIONES ANTERIORES", "TOTAL DESCUENTOS", "PAGO ", 
    "PROPUESTA DE PAGO", "DIF", "COMENTARIO", "FALTANTE", "BP+BR", "RETENCIÓN", 
    "Solicitante", "Motivo", "Fecha", "Comentario", "Percepción Com DIC C1", 
    "MONTO A GARANTIZAR (PERCEPCION - MONTO A GARANTIZAR)", "COMENTARIO.1", 
    "MONTO GARANTIZADO.1", "Apoyo Anticipo", "ACLARACIONES", 
    "COMPLEMENTO DE COMISION FIJA/VARIABLE.1", "Otros", "Total", "REGION.1", "RESICO.1", "Codigo_registro",
    #nuevas columnas
    "MES ARCH","Año_Comision", "Fecha_de_comisión","Quarter_Year", "Semester_Year","REGION CORTA", "Revenue", 
    "HSK", "Garantizado", "Territorio_Tipo","Cumple_Condiciones_Tienda_Activa","Com_Cerveza_De_Contrato", "Cumplimiento_Comision_Contrato","Porcentaje_de_hsk",
    #meses
    "Mes", "Conteo acumulado mes", "Meses_YTD", 
    #datos financieros
    "OP_Region_Mes", "Revenue_Region_Mes", "Sell_out_Region_Mes",
    #htl
    "HTL","Grupo_HTL_Mes", 
    #comisionesim
    "Indirectas", "Total Income",
    #desgloce montos
    "OC_Directas_Mes","GEC_Mes","Redenciones_Mes", "Ayudas_y_bonos_Mes",    
    #income
    "Total Income sin subsidio",
    #subsidio
    "Flag_Total_Income < 15000"
]

merged_df = merged_df[orden_columnas]

# el ultimo porcentaje de cerveza usado
lookup_dict = merged_df.drop_duplicates(subset='No.SAPDENEGOCIO', keep='last') \
                         .set_index('No.SAPDENEGOCIO')['% COMISIÓN CERVEZA'].to_dict()

# Aplicar el lookup a la nueva columna
merged_df['% COM CERVEZA ULTIMO MES'] = merged_df['No.SAPDENEGOCIO'].map(lookup_dict)

# Clasificar por tipo de Territorio
conditions = [
    ((merged_df['REGION'] == "NOROESTE") | (merged_df['ZONA'] == "NUEVO LEON") | 
     ((merged_df['REGION'] == "NORESTE") & (merged_df['ZONA'] == "VERACRUZ"))),
    ((merged_df['ZONA'].isin(["COAHUILA DURANGO", "TAMAULIPAS", "TAMAULIPAS SUR"])) |
     (merged_df['REGION'].isin(["OCCIDENTE", "CENTRO"]))),
    (merged_df['REGION'] == "SURESTE")
]
choices = ['Territorio A', 'Territorio B', 'Territorio C']

# Asignar territorios a los registros
merged_df['Territorio'] = np.select(conditions, choices, default="nan")

merged_df['Espejo % COM CERVEZA ULTIMO MES'] = merged_df['% COM CERVEZA ULTIMO MES']  

merged_df['Comisión_Cerveza con % COM CERVEZA ULTIMO MES'] = merged_df['VENTA CERVEZA'] * merged_df['Espejo % COM CERVEZA ULTIMO MES']

merged_df['Nuevo_Total_Income con % COM CERVEZA ULTIMO MES'] = (
        merged_df['Comisión_Cerveza con % COM CERVEZA ULTIMO MES']
        + merged_df['OC_Directas_Mes']
        + merged_df['GEC_Mes']
        + merged_df['Redenciones_Mes']
        + merged_df['Ayudas_y_bonos_Mes']
        + merged_df['Indirectas']
    )

###############################################################################################################

# Paso 1: Calcular Q1, Q3, IQR, límite inferior y límite superior con factor dinámico
def agregar_metricas_outliers(df):
    # Calcular Q1, Q3, IQR para cada grupo
    Q1 = df.groupby('No.SAPDENEGOCIO')['Total Income'].quantile(0.25).rename('Q1')
    Q3 = df.groupby('No.SAPDENEGOCIO')['Total Income'].quantile(0.75).rename('Q3')
    IQR = (Q3 - Q1).rename('IQR')

    # Calcular el coeficiente de variación (CV) para cada grupo
    mean = df.groupby('No.SAPDENEGOCIO')['Total Income'].mean().rename('mean')
    std_dev = df.groupby('No.SAPDENEGOCIO')['Total Income'].std().rename('std_dev')
    CV = (std_dev / mean).fillna(0).rename('CV')

    # Definir el factor basado en el CV
    factor = np.where(CV < 0.35, 1.5, 1.2)
    factor = pd.Series(factor, index=CV.index).rename('Factor_Aplicado')

    # Calcular los límites dinámicos
    limite_inferior = (Q1 - factor * IQR).rename('Limite_Inferior')
    limite_superior = (Q3 + factor * IQR).rename('Limite_Superior')

    # Unir las métricas calculadas al DataFrame original
    df = df.join(Q1, on='No.SAPDENEGOCIO')
    df = df.join(Q3, on='No.SAPDENEGOCIO')
    df = df.join(IQR, on='No.SAPDENEGOCIO')
    df = df.join(limite_inferior, on='No.SAPDENEGOCIO')
    df = df.join(limite_superior, on='No.SAPDENEGOCIO')
    df = df.join(factor, on='No.SAPDENEGOCIO')
    df = df.join(CV, on='No.SAPDENEGOCIO')

    # Crear la columna 'Outlier' indicando si el valor está fuera de los límites
    df['Outlier'] = np.where(
        (df['Total Income'] < df['Limite_Inferior']) | 
        (df['Total Income'] > df['Limite_Superior']), 
        'Fuera de rango', 
        'Normal'
    )

    return df

# Aplicar la función de agregación de métricas
merged_df = agregar_metricas_outliers(merged_df)
merged_df['CV'] = merged_df['CV'].fillna(0)
########################################################################


def promedio_12m_por_tienda(df):
    df = df.sort_values('Fecha_de_comisión')
    resultados = []

    for i, row in df.iterrows():
        fecha_limite = row['Fecha_de_comisión'] - pd.DateOffset(months=12)
        filtro = (df['Fecha_de_comisión'] > fecha_limite) & (df['Fecha_de_comisión'] <= row['Fecha_de_comisión'])
        promedio = df.loc[filtro, 'HTL'].mean()
        resultados.append(promedio)

    df['HTL_Promedio_12MOPS'] = resultados
    return df

# Aplicar por tienda
merged_df = merged_df.groupby('No.SAPDENEGOCIO', group_keys=False).apply(promedio_12m_por_tienda)

# Definir los límites de los rangos para HTL
bins = [0, 1.00000001, 1.50000001, 3.00000001, 5.00000001, 6.00000001, 8.00000001, 10.00000001, 
        11.00000001, 15.00000001, 20.00000001, 25.00000001, 30.00000001, 40.00000001, 
        60.00000001, 80.00000001, 100.00000001, float('inf')]

# Etiquetas  para cada rango
labels = ['0 a 1', '>1 a 1.5', '>1.5 a 3', '>3 a 5', '>5 a 6', '>6 a 8', '>8 a 10', 
          '>10 a 11', '>11 a 15', '>15 a 20', '>20 a 25', '>25 a 30', '>30 a 40', 
          '>40 a 60', '>60 a 80', '>80 a 100', '>100']

# Crear la nueva columna 'Grupo HTL' con los rangos correspondientes
merged_df['Grupo_HTL_12MOPS'] = pd.cut(merged_df['HTL_Promedio_12MOPS'], bins=bins, labels=labels, right=False)

#normaliza y quita decimales de la tabla de % de cerveza - hL

# Lista de valores únicos de '% CV PROP A' del dataframe
percentage_cv_prop_a = tabla_hectolitraje['% CV PROP A'].unique().tolist()
# Redondear cada valor de la lista a 3 decimales
percentage_cv_prop_a = [round(value, 3) for value in percentage_cv_prop_a]

# Lista de valores únicos de '% CV PROP B' del dataframe
percentage_cv_prop_b = tabla_hectolitraje['% CV PROP B'].unique().tolist()
# Redondear cada valor de la lista a 3 decimales
percentage_cv_prop_b = [round(value, 3) for value in percentage_cv_prop_b]

# Lista de valores únicos de '% CV PROP C' del dataframe
percentage_cv_prop_c = tabla_hectolitraje['% CV PROP C'].unique().tolist()

# Redondear cada valor de la lista a 3 decimales
percentage_cv_prop_c = [round(value, 3) for value in percentage_cv_prop_c]

def find_cv_percentage(htl, Territorio, htl_table):
    # Encontrar el índice del rango que corresponde
    try:
        # Obtener el índice del primer rango mayor o igual
        index = htl_table[htl_table['RANGO HTL'] >= htl].index[0]
        # Verificar si hay una fila anterior
        if index > 0:
            row = htl_table.iloc[index - 1]  # Fila anterior
        else:
            # Si no hay fila anterior, retornar un valor por defecto
            row = htl_table.iloc[0]  # Primera fila como fallback
    except IndexError:
        # Si no se encuentra un índice correspondiente, usar la última fila como tope
        row = htl_table.iloc[0]

    # Devolver el valor según el tipo de Territorio
    if Territorio == 'Territorio A':
        return row['% CV PROP A']
    elif Territorio == 'Territorio B':
        return row['% CV PROP B']
    elif Territorio == 'Territorio C':
        return row['% CV PROP C']
    else:
        return np.nan

# Asignar porcentajes según el territorio correspondiente
merged_df['% CV PROP'] = merged_df.apply(
    lambda row: find_cv_percentage(
        row['HTL_Promedio_12MOPS'],
        row['Territorio'],
        tabla_hectolitraje  # Nombre del DataFrame que contiene "Tabla de Hectolitraje"
    ), axis=1
)
 
# # Asignar porcentajes según el territorio correspondiente
# merged_df['% CV PROP'] = merged_df.apply(
#     lambda row: find_cv_percentage(
#         row['Grupo_HTL_12MOPS'],
#         row['Territorio'],
#         tabla_hectolitraje  # Nombre del DataFrame que contiene "Tabla de Hectolitraje"
#     ), axis=1
# )

merged_df['Comisión_Cerveza_Prop'] = merged_df['VENTA CERVEZA'] * merged_df['% CV PROP']


# Guardar el DataFrame combinado en un archivo Excel
merged_df.to_parquet(f"Base_Final_Comisiones_Outliers.parquet", index=False)

# %% [markdown]
# # Analisis de las comisiones de cerveza

# %%
#analisis de ajustes de comisión cerveza

#Tomar la información más reciente de las tiendas del ultimo final de comisiones
#filtrando solo info de los ultimos 24 meses, 12 registros como máximo por tienda

desincorporaciones = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\SA027\Acumulado Desincorporaciones.xlsx")
# Cargar el archivo como DataFrame
ultimo_final_de_comisiones = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\Final comision\2025\Junio 2025.xlsx")
ultimo_final_de_comisiones['Fecha Ingreso Tienda'] = pd.to_datetime(
    ultimo_final_de_comisiones['Fecha Ingreso Tienda'], errors='coerce'
)

ingreso_digno = 15000

# Paso 1: Fecha más reciente
fecha_mas_reciente = merged_df['Fecha_de_comisión'].max()

# Paso 2: Fecha límite (2 años antes)
fecha_limite = fecha_mas_reciente - pd.DateOffset(years=2)

# Paso 3: Filtrar últimos 2 años
merged_df = merged_df[merged_df['Fecha_de_comisión'] >= fecha_limite]
Analisis_de_comisión = merged_df

# paso 3.5 Quitar las desincorporaciones

# Crear lista de desincorporaciones
lista_desinc = desincorporaciones['Ceco'].unique().tolist()

# Filtrar Analisis_de_comisión quitando los que están en la lista de desincorporaciones
Analisis_de_comisión = Analisis_de_comisión[~Analisis_de_comisión['No.SAPDENEGOCIO'].isin(lista_desinc)]

# Paso 4: Filtrar solo mes más reciente
filtro_mes = (
    (Analisis_de_comisión['Fecha_de_comisión'].dt.year == fecha_mas_reciente.year) &
    (Analisis_de_comisión['Fecha_de_comisión'].dt.month == fecha_mas_reciente.month)
)
df_mes_reciente = Analisis_de_comisión[filtro_mes]

# Paso 5: Obtener tiendas activas en ese mes
Tiendas_Activas = df_mes_reciente['No.SAPDENEGOCIO'].unique().tolist()

# Paso 6: Filtrar todo Analisis_de_comisión con esas tiendas
Analisis_de_comisión = Analisis_de_comisión[Analisis_de_comisión['No.SAPDENEGOCIO'].isin(Tiendas_Activas)]


print(Analisis_de_comisión['STATUS'].unique())

# Paso 6.5
Analisis_de_comisión = Analisis_de_comisión[Analisis_de_comisión['Cumple_Condiciones_Tienda_Activa']]

# Paso 7: quitar outliers
Analisis_de_comisión = Analisis_de_comisión[Analisis_de_comisión['Outlier'] == 'Normal']

# Paso 8: Limitar a 12 registros más recientes por tienda (si tiene más de 12)
Analisis_de_comisión = (
    Analisis_de_comisión
    .sort_values(['No.SAPDENEGOCIO', 'Fecha_de_comisión'], ascending=[True, False])
    .groupby('No.SAPDENEGOCIO', group_keys=False)
    .apply(lambda x: x if len(x) <= 12 else x.head(12))
    .reset_index(drop=True)
)
# Exportar solo las primeras 200 filas
Analisis_de_comisión.head(200).to_excel('analisis de comisión base.xlsx',index = False)

#creacion de dicionarios y columnas
territory_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['Territorio'].to_dict()
porcentaje_de_contrato_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['Com_Cerveza_De_Contrato'].to_dict()
porcentaje_reciente_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['% COM CERVEZA ULTIMO MES'].to_dict()
porcentaje_hsk_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['Porcentaje_de_hsk'].to_dict()
CV_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['CV'].to_dict()

# Crear un diccionario con No.SAPDENEGOCIO y Fecha de antiguedad
Fecha_Ingreso_Tienda_map = dict(zip(
    ultimo_final_de_comisiones['No.SAPDENEGOCIO'].astype(str),
    ultimo_final_de_comisiones['Fecha Ingreso Tienda']
))

Analisis_de_comisión['Comisión directa(Sin subsidio)'] = Analisis_de_comisión['Total Income sin subsidio'] - Analisis_de_comisión['Indirectas']
Analisis_de_comisión['Total Income(Sin subsidio ni Com Cerveza)'] = Analisis_de_comisión['Total Income sin subsidio'] - Analisis_de_comisión['COMISIÓN CERVEZA']

pivot_count = pd.pivot_table(
    Analisis_de_comisión,
    index='No.SAPDENEGOCIO',
    values='Total Income sin subsidio',
    aggfunc='count'
).rename(columns={'Total Income sin subsidio': 'Cantidad de registros'})

pivot_analisis = pd.pivot_table(
    Analisis_de_comisión,
    index='No.SAPDENEGOCIO',
    values=['Total Income(Sin subsidio ni Com Cerveza)', 'Total Income sin subsidio', 'VENTA CERVEZA', 'HTL'],
    aggfunc='mean'
)

# Unes ambos pivots en un solo DataFrame
pivot_analisis = pivot_analisis.join(pivot_count)

pivot_analisis['Costo_Punto_Porcentual_Cerveza'] = pivot_analisis['VENTA CERVEZA'] * .01

# Agregar la columna "Territorio" al pivot usando map
pivot_analisis['Territorio'] = pivot_analisis.index.map(territory_map)
pivot_analisis['porcentaje_de_contrato'] = pivot_analisis.index.map(porcentaje_de_contrato_map)
pivot_analisis['porcentaje_reciente'] = pivot_analisis.index.map(porcentaje_reciente_map)
pivot_analisis['porcentaje_hsk'] = pivot_analisis.index.map(porcentaje_hsk_map)
pivot_analisis['CV'] = pivot_analisis.index.map(CV_map)
pivot_analisis['Fecha_Ingreso_Tienda'] = pivot_analisis.index.map(Fecha_Ingreso_Tienda_map)
pivot_analisis['Fecha_Ingreso_Tienda'] = pd.to_datetime(pivot_analisis['Fecha_Ingreso_Tienda'], errors='coerce')
###############

# Función que asigna el % segun el territorio

def find_cv_percentage(htl, Territorio, htl_table):
    # Encontrar el índice del rango que corresponde
    try:
        # Obtener el índice del primer rango mayor o igual
        index = htl_table[htl_table['RANGO HTL'] >= htl].index[0]
        # Verificar si hay una fila anterior
        if index > 0:
            row = htl_table.iloc[index - 1]  # Fila anterior
        else:
            # Si no hay fila anterior, retornar un valor por defecto
            row = htl_table.iloc[0]  # Primera fila como fallback
    except IndexError:
        # Si no se encuentra un índice correspondiente, usar la última fila como tope
        row = htl_table.iloc[0]

    # Devolver el valor según el tipo de Territorio
    if Territorio == 'Territorio A':
        return row['% CV PROP A']
    elif Territorio == 'Territorio B':
        return row['% CV PROP B']
    elif Territorio == 'Territorio C':
        return row['% CV PROP C']
    else:
        return np.nan

# Asignar porcentajes según el territorio correspondiente
pivot_analisis['% CV PROP'] = pivot_analisis.apply(
    lambda row: find_cv_percentage(
        row['HTL'],
        row['Territorio'],
        tabla_hectolitraje  # Nombre del DataFrame que contiene "Tabla de Hectolitraje"
    ), axis=1
)

pivot_analisis['Com_Cerveza_con_com_contrato'] = pivot_analisis['VENTA CERVEZA'] * pivot_analisis['porcentaje_de_contrato']
pivot_analisis['Com_Cerveza_con_com_reciente'] = pivot_analisis['VENTA CERVEZA'] * pivot_analisis['porcentaje_reciente']
pivot_analisis['Com_Cerveza_Prop'] = pivot_analisis['VENTA CERVEZA'] * pivot_analisis['% CV PROP']
pivot_analisis['Comentarios'] = ''

##########################################################################################
def simular_comision_para_ingreso_digno(row):
    com_contrato = row['porcentaje_de_contrato']
    com_sugerida = row['% CV PROP']
    costo_per_com = row['Costo_Punto_Porcentual_Cerveza']
    venta_cerveza = row['VENTA CERVEZA']
    ingreso_base = row['Total Income(Sin subsidio ni Com Cerveza)']
    tope_del_boost_de_comisión = 16700
    ingreso_digno = 15000

    lista_incrementos = [0.04, 0.045, 0.05, 0.055, 0.06, 0.065, 0.07, 0.08, 0.09, 0.1,
                         0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2,
                         0.21, 0.22, 0.23, 0.24, 0.25]

    ingreso_contrato = ingreso_base + (venta_cerveza * com_contrato)
    mejor_opcion = (com_contrato, ingreso_contrato)

    # 1: Si con la comisión sugerida ya se alcanza el ingreso digno, usarla
    ingreso_sugerido = ingreso_base + (venta_cerveza * com_sugerida)
    if ingreso_digno <= ingreso_sugerido <= tope_del_boost_de_comisión:
        return com_sugerida, ingreso_sugerido, False

    # 2. Contrato ya cumple y está por arriba de lo sugerido → intentamos bajarlo
    if ingreso_digno <= ingreso_contrato <= tope_del_boost_de_comisión and com_contrato > com_sugerida:
        posibles = [c for c in lista_incrementos if com_sugerida <= c <= com_contrato][::-1]
        for com in posibles:
            ingreso_simulado = ingreso_base + (venta_cerveza * com)
            if ingreso_digno <= ingreso_simulado <= tope_del_boost_de_comisión:
                return com, ingreso_simulado, False
        return mejor_opcion[0], mejor_opcion[1], False

    # 2. Ya cumple, no hacer nada
    if ingreso_digno <= ingreso_contrato <= tope_del_boost_de_comisión:
        return mejor_opcion[0], mejor_opcion[1], False

    # 3. Buscar dentro del rango entre contrato y sugerido
    inicio = min(com_contrato, com_sugerida)
    fin = max(com_contrato, com_sugerida)
    posibles = [c for c in lista_incrementos if inicio <= c <= fin]
    for com in posibles:
        ingreso_simulado = ingreso_base + (venta_cerveza * com)
        if ingreso_digno <= ingreso_simulado <= tope_del_boost_de_comisión:
            return com, ingreso_simulado, False
        elif ingreso_simulado < ingreso_digno:
            mejor_opcion = (com, ingreso_simulado)

    # 4. Buscar más allá si el costo lo permite
    if costo_per_com < 1000:
        posibles = [c for c in lista_incrementos if c > fin]
        for com in posibles:
            ingreso_simulado = ingreso_base + (venta_cerveza * com)
            if ingreso_digno <= ingreso_simulado <= tope_del_boost_de_comisión:
                return com, ingreso_simulado, False
            elif ingreso_simulado < ingreso_digno:
                mejor_opcion = (com, ingreso_simulado)

    # NUEVO: Validar si ni con 25% se llega
    ingreso_maximo_posible = ingreso_base + (venta_cerveza * 0.25)
    if ingreso_maximo_posible < ingreso_digno:
        return 0.25, ingreso_maximo_posible, True

    return mejor_opcion[0], mejor_opcion[1], False


def obtener_porcentaje_ajustado_y_comentario(row):
    ingreso_digno = 15000
    ingreso = row['Total Income sin subsidio']
    com_actual = row['porcentaje_de_contrato']
    com_sugerida = row['% CV PROP']
    com_reciente = row['porcentaje_reciente']
    com_hsk = row['porcentaje_hsk']
    antiguedad_dias = (fecha_mas_reciente - row['Fecha_Ingreso_Tienda']).days
    htl = row['HTL']

    if ingreso >= ingreso_digno and com_sugerida > com_actual and com_sugerida > com_reciente:
        com, ingreso_simulado, no_llega = simular_comision_para_ingreso_digno(row)
        if no_llega:
            return com, "Ni con 25% alcanza ingreso digno1", ingreso_simulado
        return com, "Ya tiene ingreso digno pero podríamos aumentar su comisión", ingreso_simulado

    elif ingreso >= ingreso_digno and com_sugerida < com_actual and com_sugerida < com_reciente:
        com, ingreso_simulado, no_llega = simular_comision_para_ingreso_digno(row)
        if no_llega:
            return com, "Ni con 25% alcanza ingreso digno2", ingreso_simulado
        return com, "Ya tiene ingreso digno pero podríamos reducir su comisión", ingreso_simulado

    elif ingreso >= ingreso_digno:
        ingreso_base = row['Total Income(Sin subsidio ni Com Cerveza)']
        com = 0
        ingreso_simulado = ingreso_base + (row['VENTA CERVEZA'] * com)
        return com, "Ya tiene ingreso digno", ingreso_simulado

    elif pd.notnull(com_hsk):
        ingreso_base = row['Total Income(Sin subsidio ni Com Cerveza)']
        ingreso_simulado = ingreso_base + (row['VENTA CERVEZA'] * com_hsk)
        return com_hsk, "Es HSK", ingreso_simulado

    elif antiguedad_dias < 365 and htl <= 11:
        ingreso_base = row['Total Income(Sin subsidio ni Com Cerveza)']
        ingreso_simulado = ingreso_base
        return 0, "New SK - La antigüedad entra en política de subsidios y promedia <=11 hL Avg", ingreso_simulado

    elif antiguedad_dias < 365 and htl > 11 and ingreso >= ingreso_digno:
        ingreso_base = row['Total Income(Sin subsidio ni Com Cerveza)']
        ingreso_simulado = ingreso_base
        return 0, "New SK - Ingreso digno, la antigüedad en política de subsidios y promedia arriba de 11 hL Avg", ingreso_simulado

    elif antiguedad_dias < 365 and htl > 11 and ingreso < ingreso_digno:
        com, ingreso_simulado, no_llega = simular_comision_para_ingreso_digno(row)
        if no_llega:
            return com, "Ni con 25% alcanza ingreso digno3", ingreso_simulado
        return com, "New SK - No alcanza ingreso digno, la antigüedad en política de subsidios y promedia arriba de 11 hL Avg", ingreso_simulado

    elif ingreso < ingreso_digno and com_sugerida <= com_actual:
        com, ingreso_simulado, no_llega = simular_comision_para_ingreso_digno(row)
        if no_llega:
            return com, "Ni con 25% alcanza ingreso digno4", ingreso_simulado
        return com, "No alcanza ingreso digno, pero ya está ajustado o excede tabulador", ingreso_simulado

    elif ingreso < ingreso_digno and com_sugerida > com_actual:
        com, ingreso_simulado, no_llega = simular_comision_para_ingreso_digno(row)
        if no_llega:
            return com, "Ni con 25% alcanza ingreso digno5", ingreso_simulado
        return com, "No alcanza ingreso digno, necesita análisis para ajuste de porcentaje", ingreso_simulado

    return None, "", None


pivot_analisis[['% Necesario para ingreso Digno', 'Comentarios', 'Ingreso Total Simulado']] = pivot_analisis.apply(
    obtener_porcentaje_ajustado_y_comentario, axis=1, result_type='expand'
)

pivot_analisis['¿Se Ajustó?'] = pivot_analisis.apply(
    lambda row: 'Sí' if row['% Necesario para ingreso Digno'] != row['porcentaje_de_contrato'] else 'No',
    axis=1
)


##########################################################################################

def calcular_diferencia(row):
    # Si el valor no es numérico, regresa 0 o np.nan
    try:
        if row['% Necesario para ingreso Digno'] == 0:
            return 0
        elif row['Comentarios'] == 'Excede el tabulador de comisión':
            return -row['% CV PROP']
        # Solo calcula si ambos son numéricos
        elif isinstance(row['% Necesario para ingreso Digno'], (int, float)) and isinstance(row['porcentaje_de_contrato'], (int, float)):
            return row['% Necesario para ingreso Digno'] - row['porcentaje_de_contrato']
        else:
            return 0  # O puedes usar np.nan si prefieres
    except Exception:
        return 0  # O np.nan


pivot_analisis['Diferencia'] = pivot_analisis.apply(calcular_diferencia, axis=1)
# Calcular costos
pivot_analisis['Costo Diferencia'] = pivot_analisis['Diferencia'] * 100 * pivot_analisis['Costo_Punto_Porcentual_Cerveza']
pivot_analisis['Costo Diferencia 12M'] = pivot_analisis['Costo Diferencia'] * 12

##########################################################################################

#pivot_analisis.head(200).to_excel('pivot.xlsx')
pivot_analisis.to_excel('pivot.xlsx')


print("Archivo guardado éxitosamente")
# Fin de medición
end_time = time.time()

# Tiempo transcurrido
elapsed_time = end_time - start_time
minutes, seconds = divmod(elapsed_time, 60)
print(f"El código tardó {int(minutes)} minutos y {seconds:.2f} segundos en ejecutarse.")

# Inicializar pygame
pygame.init()

# Ruta del archivo de audio
audio_file = r'C:\Users\dominh05\Documents\My project (37).wav'

# Verificar si el archivo existe
if not os.path.exists(audio_file):
    print(f"El archivo '{audio_file}' no existe.")
else:
    # Reproducir el archivo de audio
    pygame.mixer.music.load(audio_file)
    pygame.mixer.music.play()

    # Esperar hasta que la música termine de reproducirse
    while pygame.mixer.music.get_busy():
        pygame.time.Clock().tick(10)

# Terminar pygame
pygame.quit()

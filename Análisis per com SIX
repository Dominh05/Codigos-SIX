# %%
import pandas as pd
import time
import pygame
import os
import numpy as np
import datetime
from datetime import datetime

start_time = time.time()
# Convertir a hora legible
hora_legible = datetime.fromtimestamp(start_time).strftime("%H:%M:%S")
print("Hora legible:", hora_legible)

# Cargar el DataFrame
año_a_evaluar = 2025

#base 2025                 
base_comisiones = pd.read_parquet(r"C:\Users\dominh05\Documents\SIX\Codigos_six\Comisiones\Bases Fregonas\Final_de_comisiones_historico.parquet")

base_comisiones['Fecha_de_comisión'] = pd.to_datetime({
    'year': base_comisiones['Año_Comision'],
    'month': base_comisiones['Mes'],
    'day': 1
})

ruta_tabla_htl = r'C:\Users\dominh05\Documents\SIX\Tabulador HTL y porcentaje de comision.xlsx'

#porcentaje de contrato y de hsk
porcentaje_de_contrato = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\HSK\Tabulador Ene - Jun_2025 - Jul.xlsx")
porcentaje_de_hsk = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\Tabulador HSK comision\2025\TABULADOR HSK - COMISIÓN JULIO 2025.xlsx", sheet_name='TGT HSK')

sa039 = pd.read_excel(r'C:\Users\dominh05\Documents\SIX\Data Financiera SA039 Acumulado.xlsx', sheet_name='SA039')

diccionario_datos_finanzas = dict(zip(sa039['Llave'], sa039['Monto']))
#diccionario de comisiones
diccionario_porcentaje_contrato = dict(zip(
    porcentaje_de_contrato['No.deNegocio'].astype(str),
    porcentaje_de_contrato['Tabulador 2025']
))
diccionario_porcentaje_HSK = dict(zip(
    porcentaje_de_hsk['CeCo'].astype(str),
    porcentaje_de_hsk['CV HSK']
))

estatus_dict = {
    'ACTIVOS': 'ACTIVOS',
    'BAJAS': 'BAJAS',
    'TRANSFERENCIA': 'TRANSFERENCIA',
    'ALTA': 'ALTA',
    'REACTIVACION': 'REACTIVACION',
    'REACTIVACIÓn': 'REACTIVACION',
    'Activos': 'ACTIVOS',
    'Bajas': 'BAJAS',
    'Transfer Feb25': 'TRANSFERENCIA',
    'Alta Feb 25': 'ALTA',
    'Transfer': 'TRANSFERENCIA',
    'Alta': 'ALTA',
    'VIRTUAL 4': 'VIRTUAL 4',
    'Transferencia': 'TRANSFERENCIA'
}
base_comisiones['STATUS'] = base_comisiones['STATUS'].map(estatus_dict)

base_comisiones['Cumple_Condiciones_Tienda_Activa'] = (
    ((base_comisiones['STATUS'] == 'ACTIVOS') | (base_comisiones['STATUS'] == 'ALTA')) & 
    (base_comisiones['MODALIDAD'] != 'PENSION') & 
    (base_comisiones['SIX'] != 'INDIRECTO') & 
    (base_comisiones['OCUPACIÓN'] == 'TOTAL') & 
    (base_comisiones['DIAS LABORADOS'] >= 26)
)
# base_comisiones = base_comisiones[
#     ((base_comisiones['STATUS'] == 'ACTIVOS') | (base_comisiones['STATUS'] == 'ALTA')) & 
#     (base_comisiones['MODALIDAD'] != 'PENSION') & 
#     (base_comisiones['SIX'] != 'INDIRECTO') & 
#     (base_comisiones['OCUPACIÓN'] == 'TOTAL') & 
#     (base_comisiones['DIAS LABORADOS'] >= 26)
# ].copy()  

tabla_hectolitraje = pd.read_excel(ruta_tabla_htl)

base_comisiones['Total Income sin subsidio'] = base_comisiones['Total Income']-base_comisiones['GARANTIAS (G)'] 
merged_df = base_comisiones

merged_df['HTL'] = merged_df['HTL'].fillna(0)

# Definir los límites de los rangos para HTL
bins = [0, 1.00000001, 1.50000001, 3.00000001, 5.00000001, 6.00000001, 8.00000001, 10.00000001, 
        11.00000001, 15.00000001, 20.00000001, 25.00000001, 30.00000001, 40.00000001, 
        60.00000001, 80.00000001, 100.00000001, float('inf')]

# Etiquetas para cada rango
labels = ['0 a 1', '>1 a 1.5', '>1.5 a 3', '>3 a 5', '>5 a 6', '>6 a 8', '>8 a 10', 
          '>10 a 11', '>11 a 15', '>15 a 20', '>20 a 25', '>25 a 30', '>30 a 40', 
          '>40 a 60', '>60 a 80', '>80 a 100', '>100']


# Crear la nueva columna 'Grupo HTL' con los rangos correspondientes
merged_df['Grupo_HTL'] = pd.cut(merged_df['HTL'], bins=bins, labels=labels, right=False)

# Crear la columna condicional
merged_df['Flag_Total_Income < 15000'] = merged_df['Total Income sin subsidio'].apply(lambda x: 1 if x < 15000 else 0)

#columnas para el desgloce del income
Columnas_OC_Directas = [
    "COMPLEMENTO DE COMISION FIJA/VARIABLE",
    "CIGARROS",
    "TAE",
    "PAGO RTD'S",
    "STRONGBOW",
    "SPIRITS",
    "ENERGIZANTES (BOOST)",
    "SUEROS ORALES",
    "SIM CARDS",
    "ENCENDEDORES",
    "CANIJILLA",
    "ARTICULOS SIX",
    "FARMACIA G",
    "FARMACIA M",
    "AGUA",
    "ENERGY DRINKS",
    "SERVICIOS ELECTRONICOS",
    "URBANI y VA y VEN"
]
merged_df['OC_Directas_Mes'] = merged_df[Columnas_OC_Directas].sum(axis=1)

Columnas_GEC = [
    "INCENTIVO CATEGORIAS DIRECTAS",
    "INCENTIVO CATEGORIAS INDIRECTAS"
]

merged_df['GEC_Mes'] = merged_df[Columnas_GEC].sum(axis=1)

Columnas_Redenciones = [
    "REDENCIONES LÁCTEOS",
    "REDENCIONES REFRESCOS",
    "REDENCIONES SNACK",
    "REDENCIONES HELADOS",    
    "REDENCIONES CIGARROS", 
]

merged_df['Redenciones_Mes'] = merged_df[Columnas_Redenciones].sum(axis=1)

columnas_ayudas_y_bonos = [
    "BONO DE BIENVENIDA",
    "BONO CERVEZA",
    "BONO EJECUCIÓN",
    "INSTRUCTOR INDIRECTO",
    "APOYO TEMPORAL COMODIN",
    "INSTRUCTOR",
    "CIERRE TEMPORAL",
    "GENTE COMO TU",
    "INCENTIVO USO POS",
    "INCENTIVO GLUP",
    "APOYOS (VARIOS)",
    "CONCEPTO APOYO (VARIOS)",
    "ANTICIPOS"
]

# Asegurar que las columnas sean numéricas, reemplazando valores no numéricos con 0
merged_df[columnas_ayudas_y_bonos] = merged_df[columnas_ayudas_y_bonos].apply(pd.to_numeric, errors='coerce').fillna(0)

# Realizar la suma de las columnas
merged_df['Ayudas_y_bonos_Mes'] = merged_df[columnas_ayudas_y_bonos].sum(axis=1)

#asigna stronghold o Challenger
merged_df['Territorio_Tipo'] = merged_df['REGION'].apply(lambda x: 'Stronghold' if x in ['NORESTE', 'NOROESTE', 'SURESTE'] else 'Challenger')

merged_df['Com_Cerveza_De_Contrato'] = merged_df['No.SAPDENEGOCIO'].map(diccionario_porcentaje_contrato)
merged_df['Porcentaje_de_hsk'] = merged_df['No.SAPDENEGOCIO'].map(diccionario_porcentaje_HSK)
merged_df['Com_Cerveza_de_hsk'] = merged_df['Porcentaje_de_hsk'] * merged_df['VENTA CERVEZA'] 

merged_df['Beneficio_HSK'] = merged_df['Com_Cerveza_de_hsk'] - (merged_df['Com_Cerveza_De_Contrato'] * merged_df['VENTA CERVEZA'])

merged_df['Cumplimiento_Comision_Contrato'] = merged_df['% COMISIÓN CERVEZA'] >= merged_df['Com_Cerveza_De_Contrato']


merged_df['Codigo_registro'] = merged_df['No.SAPDENEGOCIO'].astype(str) + \
                      merged_df['NoDEPROVEEDOR'].astype(str) + \
                      merged_df['Mes'].astype(str) + \
                      merged_df['Año_Comision'].astype(str)

merged_df['Codigo_registro_Tienda'] = merged_df['No.SAPDENEGOCIO'].astype(str) + \
                      merged_df['Mes'].astype(str) + \
                      merged_df['Año_Comision'].astype(str)

merged_df['Codigo_region_periodo'] = merged_df['REGION CORTA'].astype(str) + \
                      merged_df['Mes'].astype(str) + \
                      merged_df['Año_Comision'].astype(str)

#datos financieros

# Crear las llaves con OP, REVENUE y Sell_out
merged_df["Llave_OP"] = merged_df["REGION CORTA"].astype(str) + merged_df["Mes"].astype(str) + merged_df["Año_Comision"].astype(str) + "OP"
merged_df["Llave_Revenue"] = merged_df["REGION CORTA"].astype(str) + merged_df["Mes"].astype(str) + merged_df["Año_Comision"].astype(str) + "Revenue"
merged_df["Llave_Sell_out"] = merged_df["REGION CORTA"].astype(str) + merged_df["Mes"].astype(str) + merged_df["Año_Comision"].astype(str) + "Sell_out"

# Hacer el merge con sa039 para cada tipo de dato
merged_df['OP_Region_Mes'] = merged_df['Llave_OP'].map(diccionario_datos_finanzas)
merged_df['Revenue_Region_Mes'] = merged_df['Llave_Revenue'].map(diccionario_datos_finanzas)
merged_df['Sell_out_Region_Mes'] = merged_df['Llave_Sell_out'].map(diccionario_datos_finanzas)

# Eliminar las columnas auxiliares de llave
merged_df.drop(columns=["Llave_OP", "Llave_Revenue", "Llave_Sell_out"], inplace=True)

# el ultimo porcentaje de cerveza usado
lookup_dict = merged_df.drop_duplicates(subset='No.SAPDENEGOCIO', keep='last') \
                         .set_index('No.SAPDENEGOCIO')['% COMISIÓN CERVEZA'].to_dict()

# Aplicar el lookup a la nueva columna
merged_df['% COM CERVEZA ULTIMO MES'] = merged_df['No.SAPDENEGOCIO'].map(lookup_dict)

# Clasificar por tipo de Territorio
conditions = [
    ((merged_df['REGION'] == "NOROESTE") | (merged_df['ZONA'] == "NUEVO LEON") | 
     ((merged_df['REGION'] == "NORESTE") & (merged_df['ZONA'] == "VERACRUZ"))),
    ((merged_df['ZONA'].isin(["COAHUILA DURANGO", "TAMAULIPAS", "TAMAULIPAS SUR"])) |
     (merged_df['REGION'].isin(["OCCIDENTE", "CENTRO"]))),
    (merged_df['REGION'] == "SURESTE")
]
choices = ['Territorio A', 'Territorio B', 'Territorio C']

# Asignar territorios a los registros
merged_df['Territorio'] = np.select(conditions, choices, default="nan")

###############################################################################################################

# Paso 1: Calcular Q1, Q3, IQR, límite inferior y límite superior con factor dinámico
def agregar_metricas_outliers(df):
    # Calcular Q1, Q3, IQR para cada grupo
    Q1 = df.groupby('No.SAPDENEGOCIO')['Total Income'].quantile(0.25).rename('Q1')
    Q3 = df.groupby('No.SAPDENEGOCIO')['Total Income'].quantile(0.75).rename('Q3')
    IQR = (Q3 - Q1).rename('IQR')

    # Calcular el coeficiente de variación (CV) para cada grupo
    mean = df.groupby('No.SAPDENEGOCIO')['Total Income'].mean().rename('mean')
    std_dev = df.groupby('No.SAPDENEGOCIO')['Total Income'].std().rename('std_dev')
    CV = (std_dev / mean).fillna(0).rename('CV')

    # Definir el factor basado en el CV
    factor = np.where(CV < 0.35, 1.5, 1.2)
    factor = pd.Series(factor, index=CV.index).rename('Factor_Aplicado')

    # Calcular los límites dinámicos
    limite_inferior = (Q1 - factor * IQR).rename('Limite_Inferior')
    limite_superior = (Q3 + factor * IQR).rename('Limite_Superior')

    # Unir las métricas calculadas al DataFrame original
    df = df.join(Q1, on='No.SAPDENEGOCIO')
    df = df.join(Q3, on='No.SAPDENEGOCIO')
    df = df.join(IQR, on='No.SAPDENEGOCIO')
    df = df.join(limite_inferior, on='No.SAPDENEGOCIO')
    df = df.join(limite_superior, on='No.SAPDENEGOCIO')
    df = df.join(factor, on='No.SAPDENEGOCIO')
    df = df.join(CV, on='No.SAPDENEGOCIO')

    # Crear la columna 'Outlier' indicando si el valor está fuera de los límites
    df['Outlier'] = np.where(
        (df['Total Income'] < df['Limite_Inferior']) | 
        (df['Total Income'] > df['Limite_Superior']), 
        'Fuera de rango', 
        'Normal'
    )

    return df

# Aplicar la función de agregación de métricas
merged_df = agregar_metricas_outliers(merged_df)
merged_df['CV'] = merged_df['CV'].fillna(0)

#normaliza y quita decimales de la tabla de % de cerveza - hL

# Lista de valores únicos de '% CV PROP A' del dataframe
percentage_cv_prop_a = tabla_hectolitraje['% CV PROP A'].unique().tolist()
# Redondear cada valor de la lista a 3 decimales
percentage_cv_prop_a = [round(value, 3) for value in percentage_cv_prop_a]

# Lista de valores únicos de '% CV PROP B' del dataframe
percentage_cv_prop_b = tabla_hectolitraje['% CV PROP B'].unique().tolist()
# Redondear cada valor de la lista a 3 decimales
percentage_cv_prop_b = [round(value, 3) for value in percentage_cv_prop_b]

# Lista de valores únicos de '% CV PROP C' del dataframe
percentage_cv_prop_c = tabla_hectolitraje['% CV PROP C'].unique().tolist()

# Redondear cada valor de la lista a 3 decimales
percentage_cv_prop_c = [round(value, 3) for value in percentage_cv_prop_c]

print("Shape base_comisiones:", base_comisiones.shape)
print("Suma Total Income base_comisiones:", base_comisiones['Total Income'].sum())
print("Shape merged_df:", merged_df.shape)
print("Suma Total Income merged_df:", merged_df['Total Income'].sum())

# Guardar el DataFrame combinado en un archivo Excel
merged_df.to_parquet(f"Base_Final_Comisiones_Outliers.parquet", index=False)

# Filtrar filas del año 2025
df_2025 = merged_df[merged_df['Fecha_de_comisión'].dt.year == 2025]

# Imprimir la suma de Beneficio_HSK
print("Suma Beneficio HSK 2025:", df_2025['Beneficio_HSK'].sum())

# %% [markdown]
# ## ahora si lo mero bueno miniño
# 

# %%
######################################################################################analisis de ajustes de comisión cerveza

#Tomar la información más reciente de las tiendas del ultimo final de comisiones
#filtrando solo info de los ultimos 24 meses, 12 registros como máximo por tienda

desincorporaciones = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\SA027\Acumulado Desincorporaciones.xlsx")

# Cargar el archivo como DataFrame
ultimo_final_de_comisiones = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\Final comision\2025\CÁLCULO DE COMISIÓN JULIO 25_NACIONAL.xlsx")
ultimo_final_de_comisiones['Fecha Ingreso Tienda'] = pd.to_datetime(
    ultimo_final_de_comisiones['Fecha Ingreso Tienda'], errors='coerce'
)

# Paso 1: Fecha más reciente
fecha_mas_reciente = merged_df['Fecha_de_comisión'].max()

# Paso 2: Fecha límite (2 años antes)
fecha_limite = fecha_mas_reciente - pd.DateOffset(years=2)

# Paso 3: Filtrar últimos 2 años
merged_df = merged_df[merged_df['Fecha_de_comisión'] >= fecha_limite]
Analisis_de_comisión = merged_df

ingreso_digno = 15000 *.85

# paso 3.5 Quitar las desincorporaciones

# Crear lista de desincorporaciones
lista_desinc = desincorporaciones['Ceco'].unique().tolist()

# Filtrar Analisis_de_comisión quitando los que están en la lista de desincorporaciones
Analisis_de_comisión = Analisis_de_comisión[~Analisis_de_comisión['No.SAPDENEGOCIO'].isin(lista_desinc)]

# Paso 4: Filtrar solo mes más reciente
filtro_mes = (
    (Analisis_de_comisión['Fecha_de_comisión'].dt.year == fecha_mas_reciente.year) &
    (Analisis_de_comisión['Fecha_de_comisión'].dt.month == fecha_mas_reciente.month)
)
df_mes_reciente = Analisis_de_comisión[filtro_mes]

# Paso 5: Obtener tiendas activas en ese mes
Tiendas_Activas = df_mes_reciente['No.SAPDENEGOCIO'].unique().tolist()

# Paso 6: Filtrar todo Analisis_de_comisión con esas tiendas
Analisis_de_comisión = Analisis_de_comisión[Analisis_de_comisión['No.SAPDENEGOCIO'].isin(Tiendas_Activas)]

# Paso 6.5
Analisis_de_comisión = Analisis_de_comisión[Analisis_de_comisión['Cumple_Condiciones_Tienda_Activa']]

# Paso 7: quitar outliers
Analisis_de_comisión = Analisis_de_comisión[Analisis_de_comisión['Outlier'] == 'Normal']

# Paso 8: Limitar a 12 registros más recientes por tienda (si tiene más de 12)
Analisis_de_comisión = (
    Analisis_de_comisión
    .sort_values(['No.SAPDENEGOCIO', 'Fecha_de_comisión'], ascending=[True, False])
    .groupby('No.SAPDENEGOCIO', group_keys=False)
    .apply(lambda x: x if len(x) <= 12 else x.head(12))
    .reset_index(drop=True)
)
# Exportar solo las primeras 200 filas
#Analisis_de_comisión.to_excel('analisis de comisión base.xlsx',index = False)

#creacion de dicionarios y columnas
territory_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['Territorio'].to_dict()
porcentaje_de_contrato_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['Com_Cerveza_De_Contrato'].to_dict()
porcentaje_reciente_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['% COM CERVEZA ULTIMO MES'].to_dict()
porcentaje_hsk_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['Porcentaje_de_hsk'].to_dict()
CV_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['CV'].to_dict()
Region_map = Analisis_de_comisión.set_index('No.SAPDENEGOCIO')['REGION'].to_dict()

# Crear un diccionario con No.SAPDENEGOCIO y Fecha de antiguedad
Fecha_Ingreso_Tienda_map = dict(zip(
    ultimo_final_de_comisiones['No.SAPDENEGOCIO'].astype(str),
    ultimo_final_de_comisiones['Fecha Ingreso Tienda']
))

Analisis_de_comisión['Comisión directa(Sin subsidio)'] = Analisis_de_comisión['Total Income sin subsidio'] - Analisis_de_comisión['Indirectas']
Analisis_de_comisión['Total Income(Sin subsidio ni Com Cerveza)'] = Analisis_de_comisión['Total Income sin subsidio'] - Analisis_de_comisión['COMISIÓN CERVEZA']

pivot_count = pd.pivot_table(
    Analisis_de_comisión,
    index='No.SAPDENEGOCIO',
    values='Total Income sin subsidio',
    aggfunc='count'
).rename(columns={'Total Income sin subsidio': 'Cantidad de registros'})

# Crear el pivot de análisis de comisión
pivot_1 = pd.pivot_table(
    Analisis_de_comisión,
    index='No.SAPDENEGOCIO',
    values=['Total Income(Sin subsidio ni Com Cerveza)', 'Total Income sin subsidio', 'VENTA CERVEZA', 'HTL'],
    aggfunc='mean'
)

# Unes ambos pivots en un solo DataFrame
pivot_1 = pivot_1.join(pivot_count)

pivot_1['Costo_Punto_Porcentual_Cerveza'] = pivot_1['VENTA CERVEZA'] * .01

# Asegúrate de que la columna sea datetime
Analisis_de_comisión['Fecha_de_comisión'] = pd.to_datetime(Analisis_de_comisión['Fecha_de_comisión'])

# Obtener el último registro por 'No.SAPDENEGOCIO' basado en la fecha
ultimos_proveedores = Analisis_de_comisión.sort_values('Fecha_de_comisión') \
    .groupby('No.SAPDENEGOCIO') \
    .tail(1)[['No.SAPDENEGOCIO', 'NoDEPROVEEDOR']]

# Hacemos merge para conservar solo los últimos proveedores por negocio
df_ultimos = Analisis_de_comisión.merge(
    ultimos_proveedores,
    on=['No.SAPDENEGOCIO', 'NoDEPROVEEDOR'],
    how='inner'  # solo los que coinciden con el proveedor más reciente
)

pivot_ultimos_proveedores = pd.pivot_table(
    df_ultimos,
    index='No.SAPDENEGOCIO',
    values=[
        'Total Income(Sin subsidio ni Com Cerveza)',
        'Total Income sin subsidio',
        'VENTA CERVEZA',
        'HTL'
    ],
    aggfunc='mean'
).rename(columns=lambda x: f'{x} (Último proveedor)')

pivot_analisis = pivot_1.reset_index().merge(
    pivot_ultimos_proveedores,
    on='No.SAPDENEGOCIO',
    how='left'
).set_index('No.SAPDENEGOCIO')

# Agregar la columna "Territorio" al pivot usando map
pivot_analisis['REGION'] = pivot_analisis.index.map(Region_map)
pivot_analisis['Territorio'] = pivot_analisis.index.map(territory_map)
pivot_analisis['porcentaje_de_contrato'] = pivot_analisis.index.map(porcentaje_de_contrato_map)
pivot_analisis['porcentaje_reciente'] = pivot_analisis.index.map(porcentaje_reciente_map)
pivot_analisis['porcentaje_hsk'] = pivot_analisis.index.map(porcentaje_hsk_map)
pivot_analisis['CV'] = pivot_analisis.index.map(CV_map)
pivot_analisis['Fecha_Ingreso_Tienda'] = pivot_analisis.index.map(Fecha_Ingreso_Tienda_map)
pivot_analisis['Fecha_Ingreso_Tienda'] = pd.to_datetime(pivot_analisis['Fecha_Ingreso_Tienda'], errors='coerce')

# Función que asigna el % segun el territorio

def find_cv_percentage(htl, Territorio, htl_table):
    # Encontrar el índice del rango que corresponde
    try:
        # Obtener el índice del primer rango mayor o igual
        index = htl_table[htl_table['RANGO HTL'] >= htl].index[0]
        # Verificar si hay una fila anterior
        if index > 0:
            row = htl_table.iloc[index - 1]  # Fila anterior
        else:
            # Si no hay fila anterior, retornar un valor por defecto
            row = htl_table.iloc[0]  # Primera fila como fallback
    except IndexError:
        # Si no se encuentra un índice correspondiente, usar la última fila como tope
        row = htl_table.iloc[0]

    # Devolver el valor según el tipo de Territorio
    if Territorio == 'Territorio A':
        return row['% CV PROP A']
    elif Territorio == 'Territorio B':
        return row['% CV PROP B']
    elif Territorio == 'Territorio C':
        return row['% CV PROP C']
    else:
        return row['% CV PROP A']

# Asignar porcentajes según el territorio correspondiente
pivot_analisis['% CV PROP'] = pivot_analisis.apply(
    lambda row: find_cv_percentage(
        row['HTL'],
        row['Territorio'],
        tabla_hectolitraje  # Nombre del DataFrame que contiene "Tabla de Hectolitraje"
    ), axis=1
)

pivot_analisis['Com_Cerveza_con_com_contrato'] = pivot_analisis['VENTA CERVEZA'] * pivot_analisis['porcentaje_de_contrato']
pivot_analisis['Com_Cerveza_con_com_reciente'] = pivot_analisis['VENTA CERVEZA'] * pivot_analisis['porcentaje_reciente']
pivot_analisis['Com_Cerveza_Prop'] = pivot_analisis['VENTA CERVEZA'] * pivot_analisis['% CV PROP']
pivot_analisis['Com_Cerveza_HSK'] = pivot_analisis['VENTA CERVEZA'] * pivot_analisis['porcentaje_hsk']

#saco cual porcentaje necesita para el ingreso dignos

def simular_comision_para_ingreso_digno(row):
    venta_cerveza = row['VENTA CERVEZA']
    ingreso_base = row['Total Income(Sin subsidio ni Com Cerveza)']
    ingreso_digno = 15000 * 0.85

    lista_incrementos = [0.04, 0.045, 0.05, 0.055, 0.06, 0.065, 0.07, 0.08, 0.09, 0.1,
                         0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2,
                         0.21, 0.22, 0.23, 0.24, 0.25]

    # Buscar el primer porcentaje que logre alcanzar ingreso digno
    for com in lista_incrementos:
        ingreso_simulado = ingreso_base + (venta_cerveza * com)
        ing_cerveza_simulado = venta_cerveza * com
        if ingreso_simulado >= ingreso_digno:
            (venta_cerveza * com)
            return com, ing_cerveza_simulado, False  # Lo alcanza

    # Si ni con el 25% se alcanza el ingreso digno
    ingreso_maximo_posible = ingreso_base + (venta_cerveza * 0.25)
    return .25, ingreso_maximo_posible, True

#Aplicar la simulación para calcular el porcentaje necesario
pivot_analisis[['% Necesario para ingreso Digno', 'Ingreso cerveza simulado con % necesario', 'Ni con 25% llega (Tiendas perdedoras)']] = (
    pivot_analisis.apply(simular_comision_para_ingreso_digno, axis=1, result_type='expand')
)

pivot_analisis['Comentarios'] = ''
def comparar_porcentajes(row):
    com_necesario = row['% Necesario para ingreso Digno']
    com_contrato = row['porcentaje_de_contrato']
    com_sugerida = row['% CV PROP']

    if com_contrato >= com_necesario:
        return com_contrato  # El de contrato es suficiente
    elif com_necesario <= com_sugerida:
        return com_necesario  # El sugerido puede cubrirlo
    else:
        return com_sugerida  # Aunque no alcance, es el máximo permitido

#Aplicar la comparación entre porcentajes para determinar el porcentaje final a usar
pivot_analisis['% Algoritmo'] = pivot_analisis.apply(comparar_porcentajes, axis=1)
pivot_analisis['Ingreso con % Algoritmo'] =  pivot_analisis['Total Income(Sin subsidio ni Com Cerveza)'] + (pivot_analisis['VENTA CERVEZA'] * pivot_analisis['% Algoritmo'])
pivot_analisis['dias_antiguedad'] = (fecha_mas_reciente - pivot_analisis['Fecha_Ingreso_Tienda']).dt.days

pivot_analisis.to_excel('averwey2.xlsx')


#####################################################################

def obtener_porcentaje_ajustado_y_comentario(row):
    tienda_perdedora = row.get('Ni con 25% llega (Tiendas perdedoras)')
    ingreso_digno = 15000 * 0.85
    ingreso = row.get('Total Income sin subsidio') 
    
    com_contrato = row.get('porcentaje_de_contrato')
    ing_com_contrato = (row.get('Total Income(Sin subsidio ni Com Cerveza)') or 0) + (row.get('Com_Cerveza_con_com_contrato') or 0)
    com_sugerida = row.get('% CV PROP')
    ing_com_sugerida = (row.get('Total Income(Sin subsidio ni Com Cerveza)') or 0) + (row.get('Com_Cerveza_Prop') or 0)
    com_reciente = row.get('porcentaje_reciente')
    ing_com_reciente = (row.get('Total Income(Sin subsidio ni Com Cerveza)') or 0) + (row.get('Com_Cerveza_con_com_reciente') or 0)
    com_hsk = row.get('porcentaje_hsk')
    ing_com_hsk = (row.get('Total Income(Sin subsidio ni Com Cerveza)') or 0) + (row.get('Com_Cerveza_HSK') or 0)
    com_necesario_para_Ing_digno = row.get('% Necesario para ingreso Digno')    
    ing_com_necesario_para_Ing_digno = (row.get('Total Income(Sin subsidio ni Com Cerveza)') or 0) + (row.get('Ingreso cerveza simulado con % necesario') or 0)
    com_algoritmo = row.get('% Algoritmo')    
    ing_com_algoritmo = (row.get('Total Income(Sin subsidio ni Com Cerveza)') or 0) + (row.get('Ingreso con % Algoritmo') or 0)
    
    fecha_ingreso = row.get('Fecha_Ingreso_Tienda')
    htl = row.get('HTL')

    if pd.isna(fecha_ingreso):
        return None, None

    antiguedad_dias = (fecha_mas_reciente - fecha_ingreso).days
    
    if pd.notna(com_hsk):
        if ingreso >= ingreso_digno:
            return com_hsk, ingreso
        elif ing_com_hsk >= ingreso_digno:
            return com_hsk, ing_com_hsk
        else:
            if ing_com_hsk < ingreso_digno:
                return com_hsk, ing_com_hsk
            else:
                return com_hsk, ing_com_hsk


    #aqui saco las tiendas perdedoras
    elif  tienda_perdedora == True:
        if com_sugerida > com_contrato:
            return com_sugerida, ing_com_sugerida
        else:
            return com_contrato, ing_com_contrato

#####################################################################

    #aqui capeo a los de nuevo ingreso
    elif antiguedad_dias <= 365 and ingreso >= ingreso_digno:
        return com_contrato, ingreso
        #return com_contrato, "New SK - Ingreso digno, la antigüedad en política de subsidios y promedia arriba de 11 hL Avg", ingreso
    
    elif antiguedad_dias <= 365 and htl <= 11:
        return com_contrato, ingreso
        #return com_contrato, "New SK - Subsidiado - La antigüedad entra en política de subsidios y promedia <=11 hL Avg", ingreso

    elif antiguedad_dias <= 365 and htl > 11 and ingreso < ingreso_digno:
        #aqui capeas los que con un ajuste llegan a ingreso digno
        if ing_com_algoritmo >= ingreso_digno:       
            return com_algoritmo, ing_com_algoritmo
        #aqui capeas los que con un ajuste ARRIBA DEL PROMEDIO llegan a ingreso digno
        elif ing_com_necesario_para_Ing_digno >=  ingreso_digno:
            return com_necesario_para_Ing_digno, ing_com_necesario_para_Ing_digno
    #los que no 
    elif ingreso < ingreso_digno and com_sugerida <= com_contrato:
        return com_contrato, ingreso
    
    #esta ahora si es la razita que ocupa ajuste
    elif ingreso < ingreso_digno and com_sugerida > com_contrato:
        if ing_com_algoritmo >= ingreso_digno:       
            return com_algoritmo, ing_com_algoritmo
        
        #aqui capeas los que con un ajuste ARRIBA DEL PROMEDIO llegan a ingreso digno
        elif ing_com_necesario_para_Ing_digno >=  ingreso_digno:
            return com_necesario_para_Ing_digno, ing_com_necesario_para_Ing_digno
        
    # aqui capeo a los que ya andan en sueldo digno
    elif ingreso >= ingreso_digno and com_sugerida > com_contrato and com_sugerida > com_reciente:
        return com_contrato, ingreso
    elif ingreso >= ingreso_digno and com_sugerida == com_contrato and com_sugerida == com_reciente:
        return com_contrato, ingreso
    elif ingreso >= ingreso_digno and com_sugerida < com_contrato and com_sugerida < com_reciente:
        return com_contrato, ingreso
        #return com_contrato, "Ya tiene ingreso digno pero podríamos reducir su comisión", ingreso
    elif ingreso >= ingreso_digno:
        return com_contrato, ingreso  
        #return com_contrato, "Ya tiene ingreso digno, nomas validale", ingreso       
    return None, "", None

pivot_analisis[['% Necesario para ingreso Digno', 'Ingreso Total Simulado']] = pivot_analisis.apply(
    obtener_porcentaje_ajustado_y_comentario, axis=1, result_type='expand'
)

pivot_analisis['¿Se Ajustó?'] = pivot_analisis.apply(
    lambda row: 'Sí' if row['% Algoritmo'] != row['porcentaje_de_contrato'] else 'No',
    axis=1
)


########################################################################

def calcular_diferencia(row):
    try:
        if row['% Necesario para ingreso Digno'] == 0:
            return 0
        elif row['Comentarios'] == 'Excede el tabulador de comisión':
            return -row['% CV PROP']
        elif isinstance(row['% Necesario para ingreso Digno'], (int, float)) and isinstance(row['porcentaje_de_contrato'], (int, float)):
            return row['% Algoritmo'] - row['porcentaje_de_contrato']
        else:
            return 0
    except Exception:
        return 0


pivot_analisis['Diferencia'] = pivot_analisis.apply(calcular_diferencia, axis=1)
pivot_analisis['Costo Diferencia'] = pivot_analisis['Diferencia'] * 100 * pivot_analisis['Costo_Punto_Porcentual_Cerveza']
pivot_analisis['Costo Diferencia 12M'] = pivot_analisis['Costo Diferencia'] * 12


# Definir los límites de los rangos para HTL
bins = [0, 1.00000001, 1.50000001, 3.00000001, 5.00000001, 6.00000001, 8.00000001, 10.00000001, 
        11.00000001, 15.00000001, 20.00000001, 25.00000001, 30.00000001, 40.00000001, 
        60.00000001, 80.00000001, 100.00000001, float('inf')]

# Etiquetas para cada rango
labels = ['0 a 1', '>1 a 1.5', '>1.5 a 3', '>3 a 5', '>5 a 6', '>6 a 8', '>8 a 10', 
          '>10 a 11', '>11 a 15', '>15 a 20', '>20 a 25', '>25 a 30', '>30 a 40', 
          '>40 a 60', '>60 a 80', '>80 a 100', '>100']


# Crear la nueva columna 'Grupo HTL' con los rangos correspondientes
pivot_analisis['Grupo_HTL'] = pd.cut(pivot_analisis['HTL'], bins=bins, labels=labels, right=False)

#mapear las 425 de NW
nw_425 = pd.read_excel(r"C:\Users\dominh05\Documents\SIX\425 Tiendas de NW.xlsx")
nw_425['No.SAPDENEGOCIO'] = nw_425['No.SAPDENEGOCIO'].astype(str)

# Hacemos el merge para agregar '% Prop3' al pivot_analisis
pivot_analisis = pivot_analisis.merge(
    nw_425[['No.SAPDENEGOCIO', '% Prop3']],
    on='No.SAPDENEGOCIO',
    how='left'
)

# Modificamos los valores según la condición
pivot_analisis.loc[pd.notna(pivot_analisis['% Prop3']), 'Comentarios'] = "425 de NW"
pivot_analisis.loc[pd.notna(pivot_analisis['% Prop3']), '% Algoritmo'] = pivot_analisis['% Prop3']

# Eliminamos la columna auxiliar
pivot_analisis.drop(columns=['% Prop3'], inplace=True)

#####
# el vs contra el último store keeper

# Condición 1
condicion_1 = (
    (pivot_analisis['Total Income(Sin subsidio ni Com Cerveza) (Último proveedor)'] +
     pivot_analisis['VENTA CERVEZA (Último proveedor)'] * pivot_analisis['porcentaje_de_contrato']) > ingreso_digno
) & (
    pivot_analisis['Comentarios'].isin([
        "Ni con 25% alcanza ingreso digno - Plan de rescate",
        "No alcanza ingreso digno, pero ya está ajustado o excede tabulador"
    ])
)

pivot_analisis.loc[condicion_1, 'Comentarios'] = "Plan de rescate - New SK reaches TI"

# Condición 2
condicion_2 = (
    (pivot_analisis['Total Income(Sin subsidio ni Com Cerveza) (Último proveedor)'] +
     pivot_analisis['VENTA CERVEZA (Último proveedor)'] * pivot_analisis['% CV PROP']) > ingreso_digno
) & (
    pivot_analisis['Comentarios'].isin([
        "Ni con 25% alcanza ingreso digno - Plan de rescate",
        "No alcanza ingreso digno, pero ya está ajustado o excede tabulador"
    ])
)

pivot_analisis.loc[condicion_2, 'Comentarios'] = "Plan de rescate - New SK reaches TI with adjustment"

def audiencias(row): 
    comentario = row['Comentarios']
    
    if comentario in [
        "Es HSK ya con ingreso digno",
        "Es HSK y alcanzará ingreso digno con el boost",
        "Es HSK pero necesita algo más",
        "Es HSK, validar por que no cayo en otro bracket"
    ]:
        return 'HSK'
    
    elif comentario in [
        '425 de NW',
        'Ya tiene ingreso digno',
        'Ya tiene ingreso digno pero podríamos aumentar su comisión',
        'Plan de rescate - New SK reaches TI',
        'Plan de rescate - New SK reaches TI with adjustment'
    ]:
        return 'Base'
    
    elif comentario in [
        'No alcanza ingreso digno, pero ya está ajustado o excede tabulador',
        "Ni con 25% alcanza ingreso digno, subir a comisión sugerida- Plan de rescate",
        "Ni con 25% alcanza ingreso digno, mantener en % contrato - Plan de rescate"
    ]:
        return 'Plan de rescate'
    
    elif comentario in [
        'New SK - Con ingreso digno',
        'New SK - Cubierto por política de Subsidios',  
        'New SK - Necesita ajuste extraordinario para llegar a Ingreso Digno pero andan arriba de 11 hL',
        'New SK - Necesita ajuste para llegar a Ingreso Digno'
    ]:
        return 'Nuevos SK'
    
    elif comentario in [
        'Plan de rescate -No alcanza ingreso digno - Necesita ajuste extraordinario a Ingreso Digno',
        'Plan de rescate -No alcanza ingreso digno - Necesita ajuste para llegar a Ingreso Digno'
    ]:
        return 'A Variabilizar'
    
    else:
        return 'Validar audiencia'

pivot_analisis['Audiencias'] = pivot_analisis.apply(audiencias, axis=1)

conteo_proveedores = (
    Analisis_de_comisión.groupby('No.SAPDENEGOCIO')['NoDEPROVEEDOR']
    .nunique()
    .rename('Cantidad_de_Proveedores_Distintos')
    .reset_index()
)


pivot_analisis = pivot_analisis.merge(conteo_proveedores, on='No.SAPDENEGOCIO', how='left')

# Guardar el DataFrame combinado en un archivo Excel
pivot_analisis.to_excel('pivot 3do draft.xlsx', index=False)
print("Archivo guardado éxitosamente")

# Fin de medición
end_time = time.time()

# Tiempo transcurrido
elapsed_time = end_time - start_time
minutes, seconds = divmod(elapsed_time, 60)
print(f"El código tardó {int(minutes)} minutos y {seconds:.2f} segundos en ejecutarse.")

# Inicializar pygame
pygame.init()

# Ruta del archivo de audio
audio_file = r'C:\Users\dominh05\Documents\My project (37).wav'

# Verificar si el archivo existe
if not os.path.exists(audio_file):
    print(f"El archivo '{audio_file}' no existe.")
else:
    # Reproducir el archivo de audio
    pygame.mixer.music.load(audio_file)
    pygame.mixer.music.play()

    # Esperar hasta que la música termine de reproducirse
    while pygame.mixer.music.get_busy():
        pygame.time.Clock().tick(10)

# Terminar pygame
pygame.quit()



